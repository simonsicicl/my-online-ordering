name: CI/CD Pipeline

on:
  push:
    branches: ['**']  # Run lint/test on all branches
  pull_request:
    branches: [main, develop]

jobs:
  lint-and-test:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT
      
      - name: Setup pnpm cache
        uses: actions/cache@v3
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      
      - name: Install dependencies
        run: pnpm install
      
      - name: Lint
        run: pnpm lint
      
      - name: Build
        run: pnpm build
      
      - name: Test
        run: pnpm test

  # Auto-deploy Lambda functions to Staging when develop branch is pushed
  deploy-lambda-staging:
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    needs: lint-and-test
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-west-2
      
      - name: Deploy all Lambda functions
        run: |
          deploy_lambdas() {
            local env_suffix=$1
            local deployed=0
            
            # Flat structure (lambdas/*)
            for dir in lambdas/*/; do
              [ -f "$dir/index.mjs" ] || continue
              echo "====> Deploying $(basename $dir)${env_suffix:+ to $env_suffix}..."
              cd "$dir"
              pnpm install --prod
              zip -r function.zip node_modules index.mjs package.json
              aws lambda update-function-code \
                --function-name "myordering-$(basename $dir)$env_suffix" \
                --zip-file fileb://function.zip \
                --region us-west-2 || echo "‚ö†Ô∏è Function may not exist yet"
              aws lambda wait function-updated \
                --function-name "myordering-$(basename $dir)$env_suffix" \
                --region us-west-2 2>/dev/null || true
              echo "‚úÖ Deployed"
              deployed=$((deployed + 1))
              cd ../..
            done
            
            # Nested structure (lambdas/*/*/)
            for service_dir in lambdas/*/; do
              [ -d "$service_dir" ] || continue
              for func_dir in "$service_dir"*/; do
                [ -f "$func_dir/index.mjs" ] || continue
                echo "====> Deploying $(basename $func_dir)${env_suffix:+ to $env_suffix}..."
                cd "$func_dir"
                pnpm install --prod
                zip -r function.zip node_modules index.mjs package.json
                aws lambda update-function-code \
                  --function-name "myordering-$(basename $func_dir)$env_suffix" \
                  --zip-file fileb://function.zip \
                  --region us-west-2 || echo "‚ö†Ô∏è Function may not exist yet"
                aws lambda wait function-updated \
                  --function-name "myordering-$(basename $func_dir)$env_suffix" \
                  --region us-west-2 2>/dev/null || true
                echo "‚úÖ Deployed"
                deployed=$((deployed + 1))
                cd ../../..
              done
            done
            
            echo "====================================="
            echo "Total deployed: $deployed Lambda functions"
          }
          
          deploy_lambdas ""
      
      - name: Run smoke tests
        run: |
          test_lambdas() {
            local env_suffix=$1
            local tested=0
            
            # Flat structure
            for dir in lambdas/*/; do
              [ -f "$dir/index.mjs" ] || continue
              function_name="myordering-$(basename $dir)$env_suffix"
              echo "Testing $function_name..."
              aws lambda invoke \
                --function-name "$function_name" \
                --region us-west-2 \
                response.json 2>/dev/null || echo "‚ö†Ô∏è Not found"
              [ -f response.json ] && {
                grep -q '"statusCode": 200\|"success": true' response.json 2>/dev/null && \
                  echo "‚úÖ Passed" || echo "‚ö†Ô∏è Check logs"
                rm response.json
              }
              tested=$((tested + 1))
            done
            
            # Nested structure
            for service_dir in lambdas/*/; do
              [ -d "$service_dir" ] || continue
              for func_dir in "$service_dir"*/; do
                [ -f "$func_dir/index.mjs" ] || continue
                function_name="myordering-$(basename $func_dir)$env_suffix"
                echo "Testing $function_name..."
                aws lambda invoke \
                  --function-name "$function_name" \
                  --region us-west-2 \
                  response.json 2>/dev/null || echo "‚ö†Ô∏è Not found"
                [ -f response.json ] && {
                  grep -q '"statusCode": 200\|"success": true' response.json 2>/dev/null && \
                    echo "‚úÖ Passed" || echo "‚ö†Ô∏è Check logs"
                  rm response.json
                }
                tested=$((tested + 1))
              done
            done
            
            echo "====================================="
            echo "Tested $tested Lambda functions"
          }
          
          test_lambdas ""

  # Auto-deploy to Production when main branch is pushed
  deploy-lambda-production:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    needs: lint-and-test
    runs-on: ubuntu-latest
    # Environment protection disabled for single-person development
    # Uncomment below if team grows and needs manual approval for production
    # environment:
    #   name: production
    #   url: https://myordering.com
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 8
      
      - name: Configure AWS credentials (Production)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
          aws-region: us-west-2
      
      - name: Deploy all Lambda functions to Production
        run: |
          deploy_lambdas() {
            local env_suffix=$1
            local deployed=0
            
            # Flat structure
            for dir in lambdas/*/; do
              [ -f "$dir/index.mjs" ] || continue
              echo "Deploying $(basename $dir)$env_suffix..."
              cd "$dir"
              [ -f "package.json" ] && pnpm install --prod
              zip -r function.zip . -x "*.git*" "*.md" "test/*" "*.test.js"
              aws lambda update-function-code \
                --function-name "myordering-$(basename $dir)$env_suffix" \
                --zip-file fileb://function.zip \
                --region us-west-2 && echo "‚úÖ Deployed" || echo "‚ö†Ô∏è Failed"
              rm function.zip
              cd - > /dev/null
              deployed=$((deployed + 1))
            done
            
            # Nested structure
            for service_dir in lambdas/*/; do
              [ -d "$service_dir" ] || continue
              for func_dir in "$service_dir"*/; do
                [ -f "$func_dir/index.mjs" ] || continue
                echo "Deploying $(basename $func_dir)$env_suffix..."
                cd "$func_dir"
                [ -f "package.json" ] && pnpm install --prod
                zip -r function.zip . -x "*.git*" "*.md" "test/*" "*.test.js"
                aws lambda update-function-code \
                  --function-name "myordering-$(basename $func_dir)$env_suffix" \
                  --zip-file fileb://function.zip \
                  --region us-west-2 && echo "‚úÖ Deployed" || echo "‚ö†Ô∏è Failed"
                rm function.zip
                cd - > /dev/null
                deployed=$((deployed + 1))
              done
            done
            
            echo "====================================="
            echo "Total deployed: $deployed Lambda functions"
          }
          
          deploy_lambdas "-prod"
      
      - name: Run production smoke tests
        run: |
          test_lambdas() {
            local env_suffix=$1
            local tested=0
            local failed=0
            
            # Flat structure
            for dir in lambdas/*/; do
              [ -f "$dir/index.mjs" ] || continue
              function_name="myordering-$(basename $dir)$env_suffix"
              echo "Testing $function_name..."
              aws lambda invoke \
                --function-name "$function_name" \
                --region us-west-2 \
                response.json 2>/dev/null || { echo "‚ùå Invoke failed"; failed=$((failed + 1)); continue; }
              [ -f response.json ] && {
                if grep -q '"statusCode": 200\|"success": true' response.json 2>/dev/null; then
                  echo "‚úÖ Passed"
                else
                  echo "‚ùå Failed"; cat response.json; failed=$((failed + 1))
                fi
                rm response.json
              }
              tested=$((tested + 1))
            done
            
            # Nested structure
            for service_dir in lambdas/*/; do
              [ -d "$service_dir" ] || continue
              for func_dir in "$service_dir"*/; do
                [ -f "$func_dir/index.mjs" ] || continue
                function_name="myordering-$(basename $func_dir)$env_suffix"
                echo "Testing $function_name..."
                aws lambda invoke \
                  --function-name "$function_name" \
                  --region us-west-2 \
                  response.json 2>/dev/null || { echo "‚ùå Invoke failed"; failed=$((failed + 1)); continue; }
                [ -f response.json ] && {
                  if grep -q '"statusCode": 200\|"success": true' response.json 2>/dev/null; then
                    echo "‚úÖ Passed"
                  else
                    echo "‚ùå Failed"; cat response.json; failed=$((failed + 1))
                  fi
                  rm response.json
                }
                tested=$((tested + 1))
              done
            done
            
            echo "====================================="
            echo "Tested $tested functions, $failed failed"
            [ $failed -gt 0 ] && exit 1
          }
          
          test_lambdas "-prod"
      
      - name: Notify deployment success
        run: |
          echo "====================================="
          echo "üéâ Production deployment successful!"
          echo "====================================="
          # TODO: Add Slack/Discord/Email notification in future